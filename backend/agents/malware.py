import os
import json
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_google_vertexai import ChatVertexAI
from langchain_core.tools import tool
from langchain_core.messages import ToolMessage

from backend.graph.state import AgentState
from backend.mcp.client import mcp_manager
from backend.utils.logger import get_logger
import backend.tools.gti as gti

logger = get_logger("agent_malware")

MALWARE_ANALYSIS_PROMPT = """
You are a Malware Analysis Specialist. 
Your job is to analyze the BEHAVIOR of a file to determine its capabilities, intent, and indicators.

**Input:**
1. A suspicious File Hash.
2. Triage Context (what made it suspicious).

**Tools:**
- `get_file_behavior_summary`: Provides sandbox execution results, network connections, dropped files, mutexes, MITRE ATT&CK techniques, etc.

**Analysis Steps:**
1. **Fetch Behavior:** Call `get_file_behavior_summary` for the hash.
2. **Analyze Capabilities:** 
   - Does it establish persistence? (Registry keys, scheduled tasks)
   - Does it communicate externally? (C2 IPs, Domains)
   - Is it evasive? (Anti-VM, packing)
   - What is its payload? (Ransomware, keylogger, dropper, etc.)
3. **Map to MITRE ATT&CK:** Identify specific techniques used.

**Output (JSON):**
{
    "verdict": "Malicious|Suspicious|Benign",
    "family": "e.g., Emotet, CobaltStrike (if known)",
    "capabilities": [
        "Establishes Persistence via Registry",
        "Attempts Credential Dumping",
        "Encrypts Files"
    ],
    "mitre_techniques": ["T1060", "T1003"],
    "network_indicators": ["C2 IP: 1.2.3.4", "Domain: bad.com"],
    "host_indicators": ["Mutex: Global\\X", "File: C:\\temp\\mal.exe"],
    "summary": "Concise technical summary of the malware's execution flow."
}
"""

async def malware_node(state: AgentState):
    """
    Malware Specialist Agent.
    Analyzes file behavior using Sandbox data.
    """
    ioc = state["ioc"]
    logger.info("malware_agent_start", ioc=ioc)
    
    # Check if this is actually a file hash
    # (Simple heuristic: len 32/40/64 and hex)
    # But we rely on Triage routing mostly.
    
    project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
    location = os.getenv("GOOGLE_CLOUD_REGION", "asia-southeast1")
    
    # Setup Tools
    async with mcp_manager.get_session("gti") as session:
        
        @tool
        async def get_file_behavior(file_hash: str):
            """Fetches behavioral summary for a file hash."""
            logger.info("malware_invoking_tool", tool="get_file_behavior_summary", hash=file_hash)
            try:
                res = await session.call_tool("get_file_behavior_summary", arguments={"hash": file_hash})
                if res.content:
                    return res.content[0].text
                return "{}"
            except Exception as e:
                logger.error("malware_tool_error", error=str(e))
                return f'{{"error": "{str(e)}"}}'

        llm = ChatVertexAI(
            model="gemini-2.5-flash",
            temperature=0.0,
            project=project_id,
            location=location
        ).bind_tools([get_file_behavior])
        
        # Check subtasks for specific instructions
        context = ""
        for task in state.get("subtasks", []):
            if task.get("agent") == "malware_specialist":
                context += f"- Task: {task.get('task')}\n"
                context += f"- Context: {task.get('context')}\n"
        
        messages = [
            SystemMessage(content=MALWARE_ANALYSIS_PROMPT),
            HumanMessage(content=f"""
Please analyze this file: {ioc}

Triage Context:
{context}
            """)
        ]
        
        # Agent Loop (Simple 3-turn max)
        final_content = ""
        for turn in range(3):
            response = await llm.ainvoke(messages)
            messages.append(response)
            
            if response.tool_calls:
                for tc in response.tool_calls:
                    if tc["name"] == "get_file_behavior":
                        # Execute
                        res_txt = await get_file_behavior.ainvoke(tc["args"])
                        messages.append(ToolMessage(content=res_txt, tool_call_id=tc["id"]))
            else:
                final_content = response.content
                break
        
        # Parse Result
        try:
            # Clean markdown
            clean_content = str(final_content).replace("```json", "").replace("```", "").strip()
            result = json.loads(clean_content)
            
            # Store result
            if "specialist_results" not in state:
                state["specialist_results"] = {}
                
            state["specialist_results"]["malware"] = result
            
            # Update Subtask Status
            new_subtasks = []
            for task in state.get("subtasks", []):
                if task.get("agent") == "malware_specialist":
                    task["status"] = "completed"
                    task["result_summary"] = result.get("summary")
                new_subtasks.append(task)
            state["subtasks"] = new_subtasks
            
            logger.info("malware_agent_success", verdict=result.get("verdict"))
            
        except Exception as e:
            logger.error("malware_parse_error", error=str(e))
            # Fallback
            state.setdefault("specialist_results", {})["malware"] = {
                "verdict": "Error",
                "summary": "Failed to parse analysis results."
            }
            
    return state
