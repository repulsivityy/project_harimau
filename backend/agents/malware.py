import os
import json
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage, ToolMessage
from langchain_google_vertexai import ChatVertexAI
from langchain_core.tools import tool

from backend.graph.state import AgentState
from backend.mcp.client import mcp_manager
from backend.utils.logger import get_logger
from backend.utils.graph_cache import InvestigationCache
import backend.tools.gti as gti

logger = get_logger("agent_malware")

MALWARE_ANALYSIS_PROMPT = """
You are an Elite Malware Intelligence Analyst specializing in malware analysis.

**Role:**
You are a world-class malware reverse engineer and threat intelligence analyst. Your focus is on understanding malware capabilities, tracking malware evolution, and expanding the intelligence picture. 
You think in terms of: "What does this malware reveal about the threat actor's capabilities and intent?" and "How can we use this to find more related samples?"

**Context:**
You're analyzing malware reports to build threat intelligence, not responding to an active incident. Focus on intelligence gathering, campaign tracking, and IOC expansion.

**Analysis Goals:**
1.  **Characterize Malware Capabilities:**
    *   Use `get_file_behavior` to understand technical capabilities and intent.
    *   **Classification:** Is it a loader, backdoor, stealer, ransomware, or multi-purpose toolkit?
    *   **Sophistication:** Assess evasion techniques, anti-analysis measures, code quality.
    *   **Evolution:** Look for version indicators, compilation timestamps, or development patterns.

2.  **Map Attack Infrastructure:**
    *   **C2 Infrastructure:** Extract all C2 domains, IPs, and protocols from behavior/strings.
    *   **Payload Delivery:** Identify download URLs, staging servers, or payload domains.
    *   **Exfiltration:** Look for data exfiltration endpoints or protocols.

3.  **Reconstruct Attack Chain:**
    *   Use `get_dropped_files` to identify multi-stage payloads.
    *   **Prioritize:** Analyze suspicious dropped files (executables, DLLs, scripts) using `get_file_behavior`.
    *   **Chain Mapping:** Document: Initial Sample â†’ Dropper â†’ Payload â†’ Post-Exploitation.

4.  **Attribution and Campaign Tracking:**
    *   Use `get_attribution` to link to known malware families and threat actors.
    *   Look for code similarities, shared infrastructure, or configuration patterns.
    *   Identify campaign-specific indicators (mutex names, PDB paths, encryption keys).

5.  **Intelligence Expansion:**
    *   Identify pivoting opportunities: unique strings, domain patterns, file naming conventions.
    *   Suggest YARA rules based on distinctive behaviors or code patterns.
    *   Flag indicators suitable for retrohunt or similarity searches.

**Tools:**
- `get_file_behavior`: Get sandbox execution behavior, capabilities, network activity, MITRE TTPs.
- `get_dropped_files`: List files created/dropped during execution.
- `get_attribution`: Get malware family classifications and threat actor attribution.

**Collaboration with Infrastructure Agent:**
You MUST extract and provide ALL network indicators (C2 IPs, domains, URLs) in the `network_indicators` field. The Infrastructure Agent will pivot on these to map the broader threat landscape.

**Example Output (JSON):**
{
    "verdict": "Malicious|Suspicious|Benign",
    "family": "e.g., Emotet, CobaltStrike, AgentTesla",
    "classification": "Loader|Backdoor|Stealer|Ransomware|RAT|Dropper",
    "sophistication": "Advanced|Moderate|Low",
    "intent": "Data theft|Credential harvesting|Ransomware deployment|RAT installation|Botnet",
    "capabilities": [
        "Persistence via Registry Run Key (HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run)",
        "Anti-VM detection using CPUID checks",
        "Encrypts C2 traffic using custom XOR cipher",
        "Steals browser credentials from Chrome/Firefox"
    ],
    "evasion_techniques": [
        "Process hollowing to inject into legitimate process",
        "Sleep timers to delay execution",
        "Checks for debugging tools (OllyDbg, IDA)"
    ],
    "mitre_techniques": ["T1547.001", "T1055", "T1082"],
    "attack_chain": [
        "Initial execution of loader.exe",
        "Drops encrypted payload to %APPDATA%\\svchost.dat",
        "Decrypts and executes payload using process injection",
        "Establishes persistence via scheduled task"
    ],
    "network_indicators": [
        "C2 Domain: malicious-c2.com",
        "C2 IP: 185.220.101.50",
        "Payload URL: hxxps://stage.evil[.]net/payload.bin",
        "Exfiltration endpoint: data-exfil[.]tk:8443"
    ],
    "host_indicators": [
        "Mutex: Global\\MalwareMutex2024",
        "File: C:\\Users\\Public\\svchost.exe",
        "Registry: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\SecurityUpdate",
        "PDB Path: C:\\MalDev\\Project\\Release\\loader.pdb"
    ],
    "intelligence_notes": {
        "campaign_indicators": "Mutex name matches pattern seen in previous FIN7 campaigns",
        "code_similarity": "Shares encryption routine with samples from 2023-Q4 wave",
        "pivoting_opportunities": "Search GTI for other samples with mutex 'MalwareMutex*' pattern",
        "yara_suggestions": "Rule based on unique sleep(12000) + anti-VM sequence"
    },
    "summary": "Technical intelligence summary focusing on capabilities, infrastructure, and campaign context. Include confidence levels for attribution claims."
}

**CRITICAL OUTPUT INSTRUCTIONS:**
- You MUST ALWAYS return valid JSON in the exact format shown above.
- Do NOT include markdown formatting, code blocks, or explanatory text.
- **IF TOOLS FAIL OR ERROR:** Still return JSON! Use "Unknown", empty arrays [], or "N/A" for fields you couldn't populate.
- **NEVER provide narrative explanations instead of JSON.** If you encountered errors, mention them in the "summary" field.
- When you're done analyzing, respond with ONLY the JSON object - nothing else.
- Be specific with technical details (registry paths, file locations, exact strings).
- Distinguish between confirmed findings and suspected correlations.
- Focus on intelligence value: What can we learn? What should we hunt for next?

**Example when tools fail:**
{
    "verdict": "Unknown",
    "family": "Unknown",
    "classification": "Unknown",
    "sophistication": "Unknown",
    "intent": "Unknown",
    "capabilities": [],
    "evasion_techniques": [],
    "mitre_techniques": [],
    "attack_chain": [],
    "network_indicators": [],
    "host_indicators": [],
    "intelligence_notes": {},
    "summary": "Analysis incomplete due to tool errors. Based on available data: [describe what you know]"
}
"""

def generate_malware_markdown_report(result: dict, ioc: str) -> str:
    """
    Generates a detailed markdown report for Malware Analysis.
    """
    try:
        md = "## Malware Specialist Analysis\n\n"
        md += f"### Target Hash: `{ioc}`\n\n"
        
        # 1. Threat Profile
        verdict = result.get("verdict", "Unknown")
        intent = result.get("intent", "Unknown")
        family = result.get("family", "Unknown")
        
        icon = "ðŸ”´" if verdict.lower() == "malicious" else "ðŸŸ¡" if verdict.lower() == "suspicious" else "ðŸŸ¢"
        
        md += "### ðŸŽ¯ Threat Profile\n"
        md += f"**Verdict:** {icon} {verdict}\n"
        md += f"**Family:** {family}\n"
        md += f"**Intent:** {intent}\n\n"
        
        # 2. Executive Summary
        md += "### ðŸ“‹ Intelligence Summary\n"
        md += f"{result.get('summary', 'No summary provided.')}\n\n"
        
        # 3. Malware Capabilities
        capabilities = result.get("capabilities", [])
        if capabilities:
            md += "### ðŸ›¡ï¸ Behavioral Capabilities\n"
            for cap in capabilities:
                md += f"*   {cap}\n"
            md += "\n"
        
        # 4. Evasion Techniques
        evasion = result.get("evasion_techniques", [])
        if evasion:
            md += "### ðŸ¥· Evasion & Anti-Analysis Techniques\n"
            for tech in evasion:
                md += f"*   {tech}\n"
            md += "\n"
            
        # 4. MITRE ATT&CK
        mitre = result.get("mitre_techniques", [])
        if mitre:
            md += "### ðŸ—ºï¸ MITRE ATT&CK Techniques\n"
            md += f"**Techniques:** {', '.join(mitre)}\n\n"
            
        # 5. Attack Chain
        chain = result.get("attack_chain", [])
        if chain:
            md += "### â›“ï¸ Attack Chain Reconstruction\n"
            for step in chain:
                md += f"1.  {step}\n"
            md += "\n"
            
        # 6. Dropped Files
        dropped = result.get("dropped_files", [])
        if dropped:
            md += "### ðŸ’¾ Dropped Files\n"
            for f in dropped:
                md += f"*   `{f}`\n"
            md += "\n"
            
        # 7. Network Indicators (Crucial for Infra Hunting)
        net = result.get("network_indicators", [])
        if net:
            md += "### ðŸŒ Network Indicators\n"
            for n in net:
                md += f"*   `{n}`\n"
            md += "\n"
            
        # 8. Host Indicators
        host = result.get("host_indicators", [])
        if host:
            md += "### ðŸ’» Host Indicators\n"
            for h in host:
                md += f"*   `{h}`\n"
            md += "\n"
        
        # 9. Intelligence Notes
        intel_notes = result.get("intelligence_notes", {})
        if intel_notes:
            md += "### ðŸ” Intelligence Analysis\n"
            if intel_notes.get("campaign_indicators"):
                md += f"**Campaign Indicators:** {intel_notes['campaign_indicators']}\n\n"
            if intel_notes.get("code_similarity"):
                md += f"**Code Similarity:** {intel_notes['code_similarity']}\n\n"
            if intel_notes.get("pivoting_opportunities"):
                md += f"**Pivoting Opportunities:** {intel_notes['pivoting_opportunities']}\n\n"
            if intel_notes.get("yara_suggestions"):
                md += f"**YARA Rule Suggestions:** {intel_notes['yara_suggestions']}\n\n"
        
        return md
    except Exception as e:
        return f"Error generating malware report: {str(e)}"

async def malware_node(state: AgentState):
    """
    Malware Specialist Agent (Iterative & Graph-Aware).
    Now includes: Triage context reading + Relationship expansion.
    """
    ioc = state["ioc"]
    logger.info("malware_agent_start", ioc=ioc)
    
    try:
        # Initialize cache from state
        cache = InvestigationCache(state.get("investigation_graph"))
        cache_stats_before = cache.get_stats()
        logger.info("malware_cache_loaded", stats=cache_stats_before)
        
        # [NEW] Retrieve Triage Context
        triage_context = state.get("metadata", {}).get("rich_intel", {}).get("triage_analysis", {})
        triage_summary = triage_context.get("executive_summary", "No triage summary available.")
        key_findings = triage_context.get("key_findings", [])
        logger.info("malware_triage_context_loaded", 
                   has_summary=bool(triage_summary), 
                   findings_count=len(key_findings))
        
        project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
        location = os.getenv("GOOGLE_CLOUD_REGION", "asia-southeast1")

        # --- Collect Analysis Targets (Multi-Hash) ---
        analysis_targets = []
        
        # 1. Add Root IOC if it's a file
        # Simple regex for hash (MD5, SHA1, SHA256)
        hash_pattern = r"^[a-fA-F0-9]{32,64}$"
        import re
        if re.match(hash_pattern, ioc):
            # Get full entity data from cache
            full_entity = cache.get_entity_full(ioc)
            if full_entity:
                analysis_targets.append({
                    "type": "root",
                    "hash": ioc,
                    "cached_data": {
                        "verdict": full_entity.get("gti_assessment", {}).get("verdict", {}).get("value"),
                        "threat_score": full_entity.get("gti_assessment", {}).get("threat_score", {}).get("value"),
                        "file_type": full_entity.get("type_description"),
                        "size": full_entity.get("size"),
                        "names": full_entity.get("names", [])
                    }
                })
            else:
                # Fallback: not in cache, will need to fetch
                analysis_targets.append({"type": "root", "hash": ioc})
            
        # 2. Add subtask targets (get from cache)
        for task in state.get("subtasks", []):
            if task.get("agent") in ["malware_specialist", "malware"]:
                target_id = task.get("entity_id")
                if target_id and re.match(hash_pattern, target_id):
                     # Avoid duplicates
                     if not any(t["hash"] == target_id for t in analysis_targets):
                         # Get full entity from cache
                         full_entity = cache.get_entity_full(target_id)
                         target_info = {
                             "type": "related_artifact",
                             "hash": target_id,
                             "reason": task.get("context"),
                             "task": task.get("task")
                         }
                         if full_entity:
                             target_info["cached_data"] = {
                                 "verdict": full_entity.get("gti_assessment", {}).get("verdict", {}).get("value"),
                                 "threat_score": full_entity.get("gti_assessment", {}).get("threat_score", {}).get("value"),
                                 "file_type": full_entity.get("type_description")
                             }
                         analysis_targets.append(target_info)
        
        # Limit to top 3 to prevent timeouts
        analysis_targets = analysis_targets[:3]
        logger.info("malware_targets_identified", count=len(analysis_targets), targets=[t["hash"] for t in analysis_targets])

        if not analysis_targets:
            logger.warning("malware_no_targets_found")
            return state
        
        # Setup Tools
        async with mcp_manager.get_session("gti") as session:
            
            @tool
            async def get_file_behavior(file_hash: str):
                """Fetches behavioral summary for a file hash."""
                logger.info("malware_invoking_tool", tool="get_file_behavior_summary", hash=file_hash)
                try:
                    res = await session.call_tool("get_file_behavior_summary", arguments={"hash": file_hash})
                    if res.content:
                        return res.content[0].text
                    return "{}"
                except Exception as e:
                    logger.error("malware_tool_error", error=str(e))
                    return f'{{"error": "{str(e)}"}}'

            @tool
            async def get_dropped_files(file_hash: str):
                """Fetches list of files dropped by this file during execution."""
                logger.info("malware_invoking_tool", tool="get_dropped_files", hash=file_hash)
                try:
                    # get_entities_related_to_a_file(hash, relationship_name, descriptors_only)
                    res = await session.call_tool("get_entities_related_to_a_file", arguments={
                        "hash": file_hash,
                        "relationship_name": "dropped_files",
                        "descriptors_only": True
                    })
                    if res.content:
                        return res.content[0].text
                    return "[]"
                except Exception as e:
                    logger.error("malware_tool_error", error=str(e))
                    return f'{{"error": "{str(e)}"}}'

            @tool
            async def get_attribution(file_hash: str):
                """Fetches related malware families and threat actors."""
                logger.info("malware_invoking_tool", tool="get_attribution", hash=file_hash)
                results = {}
                try:
                    # 1. Families
                    res_fam = await session.call_tool("get_entities_related_to_a_file", arguments={
                        "hash": file_hash,
                        "relationship_name": "malware_families",
                        "descriptors_only": True
                    })
                    if res_fam.content:
                        results["families"] = res_fam.content[0].text

                    # 2. Actors
                    res_act = await session.call_tool("get_entities_related_to_a_file", arguments={
                        "hash": file_hash,
                        "relationship_name": "related_threat_actors",
                        "descriptors_only": True
                    })
                    if res_act.content:
                        results["actors"] = res_act.content[0].text
                    
                    return json.dumps(results)
                except Exception as e:
                    logger.error("malware_tool_error", error=str(e))
                    return f'{{"error": "{str(e)}"}}'

            llm = ChatVertexAI(
                model="gemini-2.5-flash",
                temperature=0.0,
                project=project_id,
                location=location
            ).bind_tools([get_file_behavior, get_dropped_files, get_attribution])
            
            # [NEW] Format Triage Context for LLM
            triage_context_str = f"""**TRIAGE SUMMARY:**
{triage_summary}

**KEY FINDINGS FROM TRIAGE:**
"""
            if key_findings:
                for finding in key_findings:
                    triage_context_str += f"- {finding}\n"
            else:
                triage_context_str += "- (No specific findings listed)\n"
            
            # Check subtasks for specific instructions
            context = ""
            for task in state.get("subtasks", []):
                if task.get("agent") in ["malware_specialist", "malware"]:
                    context += f"- Task: {task.get('task')}\n"
                    context += f"- Context: {task.get('context')}\n"
            
            messages = [
                SystemMessage(content=MALWARE_ANALYSIS_PROMPT),
                HumanMessage(content=f"""
{triage_context_str}

**YOUR ASSIGNMENT:**
Analyze the following file(s) based on the triage context above:
{json.dumps(analysis_targets, indent=2)}

**SPECIFIC INSTRUCTIONS:**
{context if context else "Perform comprehensive malware analysis."}
                """)
            ]
            
            # Agent Loop (Increased to 7 iterations for comprehensive analysis)
            final_content = ""
            max_iterations = 7
            logger.info("malware_agent_loop_start", max_iterations=max_iterations)
            
            for iteration in range(max_iterations):
                logger.info("malware_agent_iteration", iteration=iteration, max_iterations=max_iterations)
                
                # If we're on the last iteration and the LLM is still calling tools, 
                # we need to force it to wrap up to provide at least some useful findings.
                if iteration == max_iterations - 1:
                    logger.info("malware_agent_final_iteration", iteration=iteration)
                    messages.append(HumanMessage(content="This is the final iteration. Please provide the comprehensive JSON structure based on the findings gathered so far."))

                response = await llm.ainvoke(messages)
                messages.append(response)
                
                if response.tool_calls:
                    logger.info("malware_agent_tool_calls", iteration=iteration, num_tools=len(response.tool_calls), tools=[tc["name"] for tc in response.tool_calls])
                    for tc in response.tool_calls:
                        tool_name = tc["name"]
                        tool_args = tc["args"]
                        logger.info("malware_invoking_tool", iteration=iteration, tool=tool_name, args=tool_args)
                        
                        if tool_name == "get_file_behavior":
                            res_txt = await get_file_behavior.ainvoke(tool_args)
                        elif tool_name == "get_dropped_files":
                            res_txt = await get_dropped_files.ainvoke(tool_args)
                        elif tool_name == "get_attribution":
                            res_txt = await get_attribution.ainvoke(tool_args)
                        else:
                            res_txt = f"Error: Tool {tool_name} not found"
                            logger.warning("malware_unknown_tool", tool=tool_name)
                            
                        messages.append(ToolMessage(content=res_txt, tool_call_id=tc["id"]))
                        logger.info("malware_tool_response", iteration=iteration, tool=tool_name, response_length=len(res_txt))
                else:
                    logger.info("malware_agent_no_tools", iteration=iteration, has_content=bool(response.content))
                    final_content = response.content
                    if final_content: # Break if we got actual answer
                        logger.info("malware_agent_final_content_received", iteration=iteration)
                        break
            
            # Fallback: If loop finished without breaking, take the last content
            if not final_content and messages:
                for msg in reversed(messages):
                    if isinstance(msg, AIMessage) and msg.content and not msg.tool_calls:
                        final_content = msg.content
                        break

            # Parse Result & [NEW] Expand Graph
            try:
                # Handle potential list of content blocks (Gemini/Vertex)
                if isinstance(final_content, list):
                    # Extract text from list of dicts or strings
                    text_parts = []
                    for block in final_content:
                        if isinstance(block, dict):
                            text_parts.append(block.get("text", ""))
                        elif isinstance(block, str):
                            text_parts.append(block)
                        else:
                            text_parts.append(str(block))
                    final_text = "".join(text_parts).strip()
                else:
                    final_text = str(final_content or "").strip()

                if not final_text:
                    raise ValueError("LLM returned empty content after analysis loop.")

                # Clean markdown and common preambles
                clean_content = final_text
                if "```json" in clean_content:
                    clean_content = clean_content.split("```json")[-1].split("```")[0].strip()
                elif "```" in clean_content:
                    clean_content = clean_content.split("```")[1].strip() if clean_content.count("```") >= 2 else clean_content
                
                # Remove any leading/trailing text that isn't part of JSON
                # Try to detect if it's an array or object
                array_start = clean_content.find("[")
                object_start = clean_content.find("{")
                
                # Determine if we have an array or object (whichever comes first)
                if array_start != -1 and (object_start == -1 or array_start < object_start):
                    # It's a JSON array
                    end_idx = clean_content.rfind("]")
                    if end_idx != -1:
                        clean_content = clean_content[array_start:end_idx+1]
                        # Parse array and take first element
                        parsed = json.loads(clean_content)
                        if isinstance(parsed, list) and len(parsed) > 0:
                            result = parsed[0]
                        else:
                            raise ValueError(f"JSON array is empty or invalid")
                    else:
                        raise ValueError(f"No closing bracket found for JSON array")
                elif object_start != -1:
                    # It's a JSON object
                    end_idx = clean_content.rfind("}")
                    if end_idx != -1:
                        clean_content = clean_content[object_start:end_idx+1]
                        result = json.loads(clean_content)
                    else:
                        raise ValueError(f"No closing brace found for JSON object")
                else:
                    # No JSON structure found
                    raise ValueError(f"No JSON structure found in LLM output. Content starts with: {final_text[:100]}")

                
                # --- NEW Reporting Logic ---
                # Generate Markdown Report Locally
                markdown_report = generate_malware_markdown_report(result, ioc)
                result["markdown_report"] = markdown_report
                
                # Store result in state
                if "specialist_results" not in state:
                    state["specialist_results"] = {}
                    
                state["specialist_results"]["malware"] = result
                
                # [RACE CONDITION FIX] Do not update final_report here.
                # Lead Hunter will assemble it to avoid race conditions.

                
                # --- POPULATE GRAPH WITH FINDINGS ---
                # 1. Network Indicators
                net_indicators = result.get("network_indicators", [])
                for indicator in net_indicators:
                    # Basic parsing: "C2 IP: 1.2.3.4" or "Domain: malicious.com" or "URL: http://malicious.com/gate.php"
                    try:
                        parts = indicator.split(":", 1)
                        if len(parts) == 2:
                            ind_type_raw = parts[0].strip().lower()
                            ind_value = parts[1].strip()
                            
                            # Determine entity type and relationship
                            entity_type = "unknown"
                            if "ip" in ind_type_raw:
                                entity_type = "ip_address"
                            elif "domain" in ind_type_raw:
                                entity_type = "domain"
                            elif "url" in ind_type_raw:
                                entity_type = "url"
                                
                            if entity_type != "unknown":
                                # Add to graph
                                cache.add_entity(ind_value, entity_type, {"malware_context": "network_indicator"})
                                cache.add_relationship(ioc, ind_value, "communicates_with", {"source": "malware_analysis"})
                                logger.info("malware_graph_update", type=entity_type, value=ind_value)
                    except Exception as e:
                         logger.warning("malware_indicator_parse_error", indicator=indicator, error=str(e))

                # 2. Dropped Files
                dropped_files = result.get("dropped_files", [])
                for dropped in dropped_files:
                    try:
                        import re
                        hash_match = re.search(r"([a-fA-F0-9]{32,64})", dropped)
                        
                        if hash_match:
                            file_hash = hash_match.group(1)
                            # Extract filename if possible (remove hash part)
                            filename = dropped.replace(hash_match.group(0), "").strip()
                            if filename.endswith("()"):
                                filename = filename[:-2].strip()
                            
                            cache.add_entity(file_hash, "file", {
                                "names": [filename] if filename else [],
                                "malware_context": "dropped_file"
                            })
                            cache.add_relationship(ioc, file_hash, "dropped", {"source": "malware_analysis"})
                            logger.info("malware_graph_update", type="file", value=file_hash)
                        else:
                            if "." in dropped: # Basic filename check
                                 file_id = f"file:{dropped}"
                                 cache.add_entity(file_id, "file", {
                                     "names": [dropped],
                                     "malware_context": "dropped_file_no_hash"
                                 })
                                 cache.add_relationship(ioc, file_id, "dropped", {"source": "malware_analysis"})
                    except Exception as e:
                        logger.warning("malware_dropped_parse_error", dropped=dropped, error=str(e))
                
                # [NEW] RELATIONSHIP EXPANSION
                # For each analyzed hash, fetch its relationships and expand the graph
                for target in analysis_targets:
                    target_hash = target["hash"]
                    logger.info("malware_expanding_relationships", hash=target_hash)
                    
                    try:
                        # Fetch relationships for this file
                        rel_data = await gti.get_file_report(
                            target_hash,
                            relationships=["dropped_files", "contacted_domains", "contacted_ips", "embedded_domains", "embedded_ips"]
                        )
                        
                        if rel_data and "data" in rel_data:
                            raw_rels = rel_data["data"].get("relationships", {})
                            new_entities_count = 0
                            
                            for rel_name, rel_content in raw_rels.items():
                                entities = rel_content.get("data", [])
                                for entity in entities:
                                    entity_id = entity.get("id")
                                    entity_type = entity.get("type")
                                    entity_attrs = entity.get("attributes", {})
                                    
                                    # Add to cache
                                    cache.add_entity(
                                        entity_id=entity_id,
                                        entity_type=entity_type,
                                        attributes=entity_attrs
                                    )
                                    cache.add_relationship(target_hash, entity_id, rel_name)
                                    new_entities_count += 1
                            
                            logger.info("malware_graph_expanded", 
                                       hash=target_hash, 
                                       new_entities=new_entities_count,
                                       relationships=list(raw_rels.keys()))
                    except Exception as expand_err:
                        logger.error("malware_expansion_error", hash=target_hash, error=str(expand_err))
                
                # [NEW] Mark all analyzed targets as investigated (for Lead Hunter tracking)
                for target in analysis_targets:
                    cache.mark_as_investigated(target["hash"], "malware")
                    logger.info("malware_marked_investigated", hash=target["hash"])
                
                # Persist expanded graph back to state
                state["investigation_graph"] = cache.graph
                cache_stats_after = cache.get_stats()
                logger.info("malware_graph_updated", 
                           before=cache_stats_before, 
                           after=cache_stats_after)

                # --- SYNC CACHE TO STATE (Frontend Graph Visibility) ---
                # The frontend uses state["metadata"]["rich_intel"]["relationships"] to build the graph.
                # We must push our new findings there.
                
                # Ensure structure exists
                if "metadata" not in state: state["metadata"] = {}
                if "rich_intel" not in state["metadata"]: state["metadata"]["rich_intel"] = {}
                if "relationships" not in state["metadata"]["rich_intel"]: state["metadata"]["rich_intel"]["relationships"] = {}
                
                relationships_data = state["metadata"]["rich_intel"]["relationships"]
                
                # Helper to push to relationships
                def push_to_rich_intel(rel_name, entity_type, value, source_id, attributes={}):
                    if rel_name not in relationships_data:
                        relationships_data[rel_name] = []
                    
                    # Check for duplicates (same ID from same Source)
                    exists = any(e.get("id") == value and e.get("source_id") == source_id for e in relationships_data[rel_name])
                    if not exists:
                        relationships_data[rel_name].append({
                            "id": value,
                            "type": entity_type,
                            "source_id": source_id,
                            "attributes": attributes
                        })

                # 1. Sync Network Indicators
                for indicator in net_indicators:
                     try:
                        parts = indicator.split(":", 1)
                        if len(parts) == 2:
                            ind_type_raw = parts[0].strip().lower()
                            ind_value = parts[1].strip()
                            
                            entity_type = "unknown"
                            if "ip" in ind_type_raw: entity_type = "ip_address"
                            elif "domain" in ind_type_raw: entity_type = "domain"
                            elif "url" in ind_type_raw: entity_type = "url"
                            
                            if entity_type != "unknown":
                                push_to_rich_intel("communicates_with", entity_type, ind_value, ioc, {"malware_context": "network_indicator"})
                     except: pass

                # 2. Sync Dropped Files
                for dropped in dropped_files:
                    try:
                        import re
                        hash_match = re.search(r"([a-fA-F0-9]{32,64})", dropped)
                        if hash_match:
                            file_hash = hash_match.group(1)
                            filename = dropped.replace(hash_match.group(0), "").strip()
                            if filename.endswith("()"): filename = filename[:-2].strip()
                            
                            push_to_rich_intel("dropped", "file", file_hash, ioc, {"meaningful_name": filename})
                        elif "." in dropped:
                             file_id = f"file:{dropped}"
                             push_to_rich_intel("dropped", "file", file_id, ioc, {"meaningful_name": dropped})
                    except: pass
                
                # Update Subtask Status
                new_subtasks = []
                for task in state.get("subtasks", []):
                    if task.get("agent") in ["malware_specialist", "malware"]:
                        task["status"] = "completed"
                        task["result_summary"] = result.get("summary")
                    new_subtasks.append(task)
                state["subtasks"] = new_subtasks
                
                logger.info("malware_agent_success", verdict=result.get("verdict"))
                
            except Exception as e:
                logger.error("malware_parse_error", error=str(e))
                # Fallback with error visibility
                import traceback
                tb = traceback.format_exc()
                state.setdefault("specialist_results", {})["malware"] = {
                    "verdict": "System Error",
                    "summary": f"Failed to parse analysis results: {str(e)}",
                    "markdown_report": f"## Analysis Failed\n\nThe Malware Agent encountered an error while processing the results.\n\n**Error Details:**\n```\n{str(e)}\n```\n\n**Raw Output:**\n```\n{str(final_text)[:2000] if 'final_text' in locals() else str(final_content)[:2000]}\n```"
                }

    except Exception as e:
        logger.error("malware_node_fatal_error", error=str(e))
        import traceback
        tb = traceback.format_exc()
        if "specialist_results" not in state: state["specialist_results"] = {}
        state["specialist_results"]["malware"] = {
            "verdict": "System Error",
            "summary": f"Fatal error in Malware Specialist: {str(e)}",
            "markdown_report": f"## System Error\n\nThe Malware Specialist encountered a fatal error.\n\n### Error Details\n```\n{str(e)}\n```\n\n### Traceback\n```\n{tb}\n```"
        }

    return state
