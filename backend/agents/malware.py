import os
import json
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_google_vertexai import ChatVertexAI
from langchain_core.tools import tool
from langchain_core.messages import ToolMessage

from backend.graph.state import AgentState
from backend.mcp.client import mcp_manager
from backend.utils.logger import get_logger
from backend.utils.graph_cache import InvestigationCache
import backend.tools.gti as gti

logger = get_logger("agent_malware")

MALWARE_ANALYSIS_PROMPT = """
You are an Elite Malware Behavioral Analysis Expert (V2 Structured Data).

**Role:**
You are a world-class malware reverse engineer and behavioral analyst. You don't just look at detection ratios; you dissect the malware's behavior to understand its true intent. You think in terms of malware capabilities, attack vectors, and TTPs, always asking "What does this behavior tell us about the malware's purpose?"

**Goal:**
Analyze the file hash to identify key malicious behaviors, understand attack mechanisms, and payload delivery.
1.  **Analyze Primary Behavior:** Use `get_file_behavior` to understand "Why" and "How".
    *   **Intent:** Is it Ransomware (encrypting)? Spyware (stealing)? Downloader?
    *   **Capabilities:** Don't just list "RegKey Created". Ask: "Is this for persistence? Is it replacing a system file? Is it checking for a debugger?"
    *   **C2:** Look for command line arguments or string artifacts that look like C2 addresses, even if no connection was made.
2.  **Analyze Dropped Files (Attack Chain):**
    *   Use `get_dropped_files` to see what was dropped.
    *   **Hunt Strategy:** Don't analyze every file. Pick the suspicious ones (e.g., .exe dropped in Temp by a PDF). Call `get_file_behavior` on them.
    *   **Chain:** Reconstruct: Initial Loader -> Drops Payload -> Executes Payload.
3.  **Attribution:** Use `get_attribution` to find related families and actors.

**Tools:**
- `get_file_behavior`: Get sandbox behavior summary (capabilities, network, mitre).
- `get_dropped_files`: List files dropped by this sample.
- `get_attribution`: Get malware families and threat actors.

**Collaboration:**
You MUST identify network indicators (C2 IPs, Domains) and explicitly list them in the `network_indicators` field for the Infrastructure Hunting Agent.

**Output (JSON):**
{
    "verdict": "Malicious|Suspicious|Benign",
    "family": "e.g., Emotet, CobaltStrike",
    "intent": "Ransomware|Spyware|Downloader|etc.",
    "capabilities": [
        "Persistence via Registry Run Key (HKCU...)",
        "Privilege Escalation via UAC Bypass"
    ],
    "mitre_techniques": ["T1060", "T1003"],
    "attack_chain": [
        "Initial execution of sample.exe",
        "Dropped payload.exe in %TEMP%",
        "Executed payload.exe via cmd.exe"
    ],
    "network_indicators": ["C2 IP: 1.2.3.4", "Domain: malicious.com"],
    "host_indicators": ["Mutex: Global\\X", "File: C:\\temp\\mal.exe"],
    "summary": "Deep technical summary of behavior and intent..."
}

**OUTPUT INSTRUCTIONS:**
- Return ONLY valid JSON.
- Do NOT include markdown formatting in the output.
"""

def generate_malware_markdown_report(result: dict, ioc: str) -> str:
    """
    Generates a detailed markdown report for Malware Analysis.
    """
    try:
        md = "## Malware Specialist Analysis\n\n"
        md += f"### Target Hash: `{ioc}`\n\n"
        
        # 1. Verdict & Intent
        verdict = result.get("verdict", "Unknown")
        intent = result.get("intent", "Unknown")
        family = result.get("family", "Unknown")
        
        icon = "üî¥" if verdict.lower() == "malicious" else "mod_detect_suspicious" if verdict.lower() == "suspicious" else "üü¢"
        
        md += f"**Verdict:** {icon} {verdict}\n"
        md += f"**Family:** {family}\n"
        md += f"**Intent:** {intent}\n\n"
        
        # 2. Executive Summary
        md += "### Executive Summary\n"
        md += f"{result.get('summary', 'No summary provided.')}\n\n"
        
        # 3. Behavioral Analysis (Capabilities)
        capabilities = result.get("capabilities", [])
        if capabilities:
            md += "### üõ°Ô∏è Behavioral Capabilities\n"
            for cap in capabilities:
                md += f"*   {cap}\n"
            md += "\n"
            
        # 4. MITRE ATT&CK
        mitre = result.get("mitre_techniques", [])
        if mitre:
            md += "### üó∫Ô∏è MITRE ATT&CK Techniques\n"
            md += f"**Techniques:** {', '.join(mitre)}\n\n"
            
        # 5. Attack Chain
        chain = result.get("attack_chain", [])
        if chain:
            md += "### ‚õìÔ∏è Attack Chain Reconstruction\n"
            for step in chain:
                md += f"1.  {step}\n"
            md += "\n"
            
        # 6. Dropped Files
        dropped = result.get("dropped_files", [])
        if dropped:
            md += "### üíæ Dropped Files\n"
            for f in dropped:
                md += f"*   `{f}`\n"
            md += "\n"
            
        # 7. Network Indicators (Crucial for Infra Hunting)
        net = result.get("network_indicators", [])
        if net:
            md += "### üåê Network Indicators\n"
            for n in net:
                md += f"*   `{n}`\n"
            md += "\n"
            
        # 8. Host Indicators
        host = result.get("host_indicators", [])
        if host:
            md += "### üíª Host Indicators\n"
            for h in host:
                md += f"*   `{h}`\n"
        
        return md
    except Exception as e:
        return f"Error generating malware report: {str(e)}"

async def malware_node(state: AgentState):
    """
    Malware Specialist Agent.
    Uses NetworkX cache for entity data, MCP for additional context.
    """
    ioc = state["ioc"]
    logger.info("malware_agent_start", ioc=ioc)
    
    # Initialize cache from state
    cache = InvestigationCache(state.get("investigation_graph"))
    cache_stats = cache.get_stats()
    logger.info("malware_cache_loaded", stats=cache_stats)
    
    project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
    location = os.getenv("GOOGLE_CLOUD_REGION", "asia-southeast1")

    # --- Collect Analysis Targets (Multi-Hash) ---
    analysis_targets = []
    
    # 1. Add Root IOC if it's a file
    # Simple regex for hash (MD5, SHA1, SHA256)
    hash_pattern = r"^[a-fA-F0-9]{32,64}$"
    import re
    if re.match(hash_pattern, ioc):
        # Get full entity data from cache
        full_entity = cache.get_entity_full(ioc)
        if full_entity:
            analysis_targets.append({
                "type": "root",
                "hash": ioc,
                "cached_data": {
                    "verdict": full_entity.get("gti_assessment", {}).get("verdict", {}).get("value"),
                    "threat_score": full_entity.get("gti_assessment", {}).get("threat_score", {}).get("value"),
                    "file_type": full_entity.get("type_description"),
                    "size": full_entity.get("size"),
                    "names": full_entity.get("names", [])
                }
            })
        else:
            # Fallback: not in cache, will need to fetch
            analysis_targets.append({"type": "root", "hash": ioc})
        
    # 2. Add subtask targets (get from cache)
    for task in state.get("subtasks", []):
        if task.get("agent") in ["malware_specialist", "malware"]:
            target_id = task.get("entity_id")
            if target_id and re.match(hash_pattern, target_id):
                 # Avoid duplicates
                 if not any(t["hash"] == target_id for t in analysis_targets):
                     # Get full entity from cache
                     full_entity = cache.get_entity_full(target_id)
                     target_info = {
                         "type": "related_artifact",
                         "hash": target_id,
                         "reason": task.get("context")
                     }
                     if full_entity:
                         target_info["cached_data"] = {
                             "verdict": full_entity.get("gti_assessment", {}).get("verdict", {}).get("value"),
                             "threat_score": full_entity.get("gti_assessment", {}).get("threat_score", {}).get("value"),
                             "file_type": full_entity.get("type_description")
                         }
                     analysis_targets.append(target_info)
    
    # Limit to top 3 to prevent timeouts
    analysis_targets = analysis_targets[:3]
    logger.info("malware_targets_identified", count=len(analysis_targets), targets=[t["hash"] for t in analysis_targets])

    if not analysis_targets:
        logger.warning("malware_no_targets_found")
        return state
    
    # Setup Tools
    async with mcp_manager.get_session("gti") as session:
        
        @tool
        async def get_file_behavior(file_hash: str):
            """Fetches behavioral summary for a file hash."""
            logger.info("malware_invoking_tool", tool="get_file_behavior_summary", hash=file_hash)
            try:
                res = await session.call_tool("get_file_behavior_summary", arguments={"hash": file_hash})
                if res.content:
                    return res.content[0].text
                return "{}"
            except Exception as e:
                logger.error("malware_tool_error", error=str(e))
                return f'{{"error": "{str(e)}"}}'

        @tool
        async def get_dropped_files(file_hash: str):
            """Fetches list of files dropped by this file during execution."""
            logger.info("malware_invoking_tool", tool="get_dropped_files", hash=file_hash)
            try:
                # get_entities_related_to_a_file(hash, relationship_name, descriptors_only)
                res = await session.call_tool("get_entities_related_to_a_file", arguments={
                    "hash": file_hash,
                    "relationship_name": "dropped_files",
                    "descriptors_only": True
                })
                if res.content:
                    return res.content[0].text
                return "[]"
            except Exception as e:
                logger.error("malware_tool_error", error=str(e))
                return f'{{"error": "{str(e)}"}}'

        @tool
        async def get_attribution(file_hash: str):
            """Fetches related malware families and threat actors."""
            logger.info("malware_invoking_tool", tool="get_attribution", hash=file_hash)
            results = {}
            try:
                # 1. Families
                res_fam = await session.call_tool("get_entities_related_to_a_file", arguments={
                    "hash": file_hash,
                    "relationship_name": "malware_families",
                    "descriptors_only": True
                })
                if res_fam.content:
                    results["families"] = res_fam.content[0].text

                # 2. Actors
                res_act = await session.call_tool("get_entities_related_to_a_file", arguments={
                    "hash": file_hash,
                    "relationship_name": "related_threat_actors",
                    "descriptors_only": True
                })
                if res_act.content:
                    results["actors"] = res_act.content[0].text
                
                return json.dumps(results)
            except Exception as e:
                logger.error("malware_tool_error", error=str(e))
                return f'{{"error": "{str(e)}"}}'

        llm = ChatVertexAI(
            model="gemini-2.5-flash",
            temperature=0.0,
            project=project_id,
            location=location
        ).bind_tools([get_file_behavior, get_dropped_files, get_attribution])
        
        # Check subtasks for specific instructions
        context = ""
        for task in state.get("subtasks", []):
            if task.get("agent") == "malware_specialist":
                context += f"- Task: {task.get('task')}\n"
                context += f"- Context: {task.get('context')}\n"
        
        messages = [
            SystemMessage(content=MALWARE_ANALYSIS_PROMPT),
            HumanMessage(content=f"""
Please analyze these files:
{json.dumps(analysis_targets, indent=2)}

Triage Context:
{context}

Remember your goal:
1. Explain the "Why" and "How" of behavior.
2. Reconstruct the Attack Chain (look at dropped files).
3. Find Attribution.
            """)
        ]
        
        # Agent Loop (Simple 3-turn max)
        final_content = ""
        for turn in range(3):
            response = await llm.ainvoke(messages)
            messages.append(response)
            
            if response.tool_calls:
                for tc in response.tool_calls:
                    tool_name = tc["name"]
                    tool_args = tc["args"]
                    
                    if tool_name == "get_file_behavior":
                        res_txt = await get_file_behavior.ainvoke(tool_args)
                    elif tool_name == "get_dropped_files":
                        res_txt = await get_dropped_files.ainvoke(tool_args)
                    elif tool_name == "get_attribution":
                        res_txt = await get_attribution.ainvoke(tool_args)
                    else:
                        res_txt = f"Error: Tool {tool_name} not found"
                        
                    messages.append(ToolMessage(content=res_txt, tool_call_id=tc["id"]))
            else:
                final_content = response.content
                break
        
        # Parse Result
        try:
            # Handle potential list of content blocks (Gemini/Vertex)
            if isinstance(final_content, list):
                final_text = "".join([
                    block.get("text", "") if isinstance(block, dict) else str(block)
                    for block in final_content
                ])
            else:
                final_text = str(final_content)

            # Clean markdown
            clean_content = final_text.replace("```json", "").replace("```", "").strip()
            result = json.loads(clean_content)
            
            # --- NEW Reporting Logic ---
            # Generate Markdown Report Locally
            markdown_report = generate_malware_markdown_report(result, ioc)
            result["markdown_report"] = markdown_report
            
            # Store result in state
            if "specialist_results" not in state:
                state["specialist_results"] = {}
                
            state["specialist_results"]["malware"] = result
            
            # --- POPULATE GRAPH WITH FINDINGS ---
            # 1. Network Indicators
            net_indicators = result.get("network_indicators", [])
            for indicator in net_indicators:
                # Basic parsing: "C2 IP: 1.2.3.4" or "Domain: malicious.com" or "URL: http://malicious.com/gate.php"
                try:
                    parts = indicator.split(":", 1)
                    if len(parts) == 2:
                        ind_type_raw = parts[0].strip().lower()
                        ind_value = parts[1].strip()
                        
                        # Determine entity type and relationship
                        entity_type = "unknown"
                        if "ip" in ind_type_raw:
                            entity_type = "ip_address"
                        elif "domain" in ind_type_raw:
                            entity_type = "domain"
                        elif "url" in ind_type_raw:
                            entity_type = "url"
                            
                        if entity_type != "unknown":
                            # Add to graph
                            cache.add_entity(ind_value, entity_type, {"malware_context": "network_indicator"})
                            cache.add_relationship(ioc, ind_value, "communicates_with", {"source": "malware_analysis"})
                            logger.info("malware_graph_update", type=entity_type, value=ind_value)
                except Exception as e:
                     logger.warning("malware_indicator_parse_error", indicator=indicator, error=str(e))

            # 2. Dropped Files
            dropped_files = result.get("dropped_files", [])
            for dropped in dropped_files:
                try:
                    # Parsing "filename (SHA256: hash)" or just "filename"
                    # Simple heuristic: look for hash pattern
                    import re
                    hash_match = re.search(r"([a-fA-F0-9]{32,64})", dropped)
                    
                    if hash_match:
                        file_hash = hash_match.group(1)
                        # Extract filename if possible (remove hash part)
                        filename = dropped.replace(hash_match.group(0), "").strip()
                        if filename.endswith("()"):
                            filename = filename[:-2].strip()
                        
                        cache.add_entity(file_hash, "file", {
                            "names": [filename] if filename else [],
                            "malware_context": "dropped_file"
                        })
                        cache.add_relationship(ioc, file_hash, "dropped", {"source": "malware_analysis"})
                        logger.info("malware_graph_update", type="file", value=file_hash)
                    else:
                        # Just a filename? Create a node but ID is tricky. 
                        # Use "file:<filename>" as ID if no hash?
                        # For now, skip if no hash to avoid polluting graph with non-unique names
                        if "." in dropped: # Basic filename check
                             file_id = f"file:{dropped}"
                             cache.add_entity(file_id, "file", {
                                 "names": [dropped],
                                 "malware_context": "dropped_file_no_hash"
                             })
                             cache.add_relationship(ioc, file_id, "dropped", {"source": "malware_analysis"})
                except Exception as e:
                    logger.warning("malware_dropped_parse_error", dropped=dropped, error=str(e))
            
            # --- SYNC CACHE TO STATE (Frontend Graph Visibility) ---
            # The frontend uses state["metadata"]["rich_intel"]["relationships"] to build the graph.
            # We must push our new findings there.
            
            # Ensure structure exists
            if "metadata" not in state: state["metadata"] = {}
            if "rich_intel" not in state["metadata"]: state["metadata"]["rich_intel"] = {}
            if "relationships" not in state["metadata"]["rich_intel"]: state["metadata"]["rich_intel"]["relationships"] = {}
            
            relationships_data = state["metadata"]["rich_intel"]["relationships"]
            
            # Helper to push to relationships
            def push_to_rich_intel(rel_name, entity_type, value, attributes={}):
                if rel_name not in relationships_data:
                    relationships_data[rel_name] = []
                
                # Check for duplicates
                exists = any(e.get("id") == value for e in relationships_data[rel_name])
                if not exists:
                    relationships_data[rel_name].append({
                        "id": value,
                        "type": entity_type,
                        "attributes": attributes
                    })

            # 1. Sync Network Indicators
            for indicator in net_indicators:
                 try:
                    parts = indicator.split(":", 1)
                    if len(parts) == 2:
                        ind_type_raw = parts[0].strip().lower()
                        ind_value = parts[1].strip()
                        
                        entity_type = "unknown"
                        if "ip" in ind_type_raw: entity_type = "ip_address"
                        elif "domain" in ind_type_raw: entity_type = "domain"
                        elif "url" in ind_type_raw: entity_type = "url"
                        
                        if entity_type != "unknown":
                            push_to_rich_intel("communicates_with", entity_type, ind_value, {"malware_context": "network_indicator"})
                 except: pass

            # 2. Sync Dropped Files
            for dropped in dropped_files:
                try:
                    import re
                    hash_match = re.search(r"([a-fA-F0-9]{32,64})", dropped)
                    if hash_match:
                        file_hash = hash_match.group(1)
                        filename = dropped.replace(hash_match.group(0), "").strip()
                        if filename.endswith("()"): filename = filename[:-2].strip()
                        
                        push_to_rich_intel("dropped", "file", file_hash, {"meaningful_name": filename})
                    elif "." in dropped:
                         file_id = f"file:{dropped}"
                         push_to_rich_intel("dropped", "file", file_id, {"meaningful_name": dropped})
                except: pass
            
            # Update Subtask Status
            new_subtasks = []
            for task in state.get("subtasks", []):
                if task.get("agent") == "malware_specialist":
                    task["status"] = "completed"
                    task["result_summary"] = result.get("summary")
                new_subtasks.append(task)
            state["subtasks"] = new_subtasks
            
            logger.info("malware_agent_success", verdict=result.get("verdict"))
            
        except Exception as e:
            logger.error("malware_parse_error", error=str(e))
            # Fallback with error visibility
            import traceback
            tb = traceback.format_exc()
            state.setdefault("specialist_results", {})["malware"] = {
                "verdict": "System Error",
                "summary": f"Failed to parse analysis results: {str(e)}",
                "markdown_report": f"## Analysis Failed\n\nThe Malware Agent encountered an error while processing the results.\n\n**Error Details:**\n```\n{str(e)}\n```\n\n**Raw Output:**\n```\n{str(final_content)[:500]}\n```"
            }
            
    return state
