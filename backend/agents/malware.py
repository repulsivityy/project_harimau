import os
import json
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_google_vertexai import ChatVertexAI
from langchain_core.tools import tool
from langchain_core.messages import ToolMessage

from backend.graph.state import AgentState
from backend.mcp.client import mcp_manager
from backend.utils.logger import get_logger
from backend.utils.graph_cache import InvestigationCache
import backend.tools.gti as gti

logger = get_logger("agent_malware")

MALWARE_ANALYSIS_PROMPT = """
You are a Malware Analysis Specialist. 
Your job is to analyze the BEHAVIOR of one or more file hashes to determine capabilities, intent, and indicators.

**Input:**
1. A list of suspicious File Hashes (Root IOC + Related Artifacts).
2. Triage Context.
3. Full entity data from investigation cache (includes all GTI attributes).

**Tools:**
- `get_file_behavior`: Provides sandbox execution results, network connections, dropped files, mutexes, MITRE ATT&CK techniques, etc.

**Analysis Steps:**
1. **Review Cached Data:** Check the pre-fetched entity data provided (includes verdicts, scores, basic attributes).
2. **Fetch Behavior:** Call `get_file_behavior` for EACH unique hash to get sandbox execution details.
3. **Analyze Capabilities:** 
   - Does it establish persistence? (Registry keys, scheduled tasks)
   - Does it communicate externally? (C2 IPs, Domains)
   - Is it evasive? (Anti-VM, packing)
   - What is its payload? (Ransomware, keylogger, dropper, etc.)
4. **Map to MITRE ATT&CK:** Identify specific techniques used.

**Output (JSON):**
{
    "verdict": "Malicious|Suspicious|Benign",
    "family": "e.g., Emotet, CobaltStrike (if known)",
    "capabilities": [
        "Establishes Persistence via Registry",
        "Attempts Credential Dumping",
        "Encrypts Files"
    ],
    "mitre_techniques": ["T1060", "T1003"],
    "network_indicators": ["C2 IP: 1.2.3.4", "Domain: bad.com"],
    "host_indicators": ["Mutex: Global\\X", "File: C:\\temp\\mal.exe"],
    "summary": "Concise technical summary of the malware's execution flow.",
    "markdown_report": "## Malware Specialist Analysis\\n\\n### Hash: <hash>\\n**Verdict:** ...\\n\\n**Capabilities:**\\n- ...\\n\\n**MITRE ATT&CK:**\\n- ...\\n"
}
"""

async def malware_node(state: AgentState):
    """
    Malware Specialist Agent.
    Uses NetworkX cache for entity data, MCP for additional context.
    """
    ioc = state["ioc"]
    logger.info("malware_agent_start", ioc=ioc)
    
    # Initialize cache from state
    cache = InvestigationCache(state.get("investigation_graph"))
    cache_stats = cache.get_stats()
    logger.info("malware_cache_loaded", stats=cache_stats)
    
    project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
    location = os.getenv("GOOGLE_CLOUD_REGION", "asia-southeast1")

    # --- Collect Analysis Targets (Multi-Hash) ---
    analysis_targets = []
    
    # 1. Add Root IOC if it's a file
    # Simple regex for hash (MD5, SHA1, SHA256)
    hash_pattern = r"^[a-fA-F0-9]{32,64}$"
    import re
    if re.match(hash_pattern, ioc):
        # Get full entity data from cache
        full_entity = cache.get_entity_full(ioc)
        if full_entity:
            analysis_targets.append({
                "type": "root",
                "hash": ioc,
                "cached_data": {
                    "verdict": full_entity.get("gti_assessment", {}).get("verdict", {}).get("value"),
                    "threat_score": full_entity.get("gti_assessment", {}).get("threat_score", {}).get("value"),
                    "file_type": full_entity.get("type_description"),
                    "size": full_entity.get("size"),
                    "names": full_entity.get("names", [])
                }
            })
        else:
            # Fallback: not in cache, will need to fetch
            analysis_targets.append({"type": "root", "hash": ioc})
        
    # 2. Add subtask targets (get from cache)
    for task in state.get("subtasks", []):
        if task.get("agent") in ["malware_specialist", "malware"]:
            target_id = task.get("entity_id")
            if target_id and re.match(hash_pattern, target_id):
                 # Avoid duplicates
                 if not any(t["hash"] == target_id for t in analysis_targets):
                     # Get full entity from cache
                     full_entity = cache.get_entity_full(target_id)
                     target_info = {
                         "type": "related_artifact",
                         "hash": target_id,
                         "reason": task.get("context")
                     }
                     if full_entity:
                         target_info["cached_data"] = {
                             "verdict": full_entity.get("gti_assessment", {}).get("verdict", {}).get("value"),
                             "threat_score": full_entity.get("gti_assessment", {}).get("threat_score", {}).get("value"),
                             "file_type": full_entity.get("type_description")
                         }
                     analysis_targets.append(target_info)
    
    # Limit to top 3 to prevent timeouts
    analysis_targets = analysis_targets[:3]
    logger.info("malware_targets_identified", count=len(analysis_targets), targets=[t["hash"] for t in analysis_targets])

    if not analysis_targets:
        logger.warning("malware_no_targets_found")
        return state
    
    # Setup Tools
    async with mcp_manager.get_session("gti") as session:
        
        @tool
        async def get_file_behavior(file_hash: str):
            """Fetches behavioral summary for a file hash."""
            logger.info("malware_invoking_tool", tool="get_file_behavior_summary", hash=file_hash)
            try:
                res = await session.call_tool("get_file_behavior_summary", arguments={"hash": file_hash})
                if res.content:
                    return res.content[0].text
                return "{}"
            except Exception as e:
                logger.error("malware_tool_error", error=str(e))
                return f'{{"error": "{str(e)}"}}'

        llm = ChatVertexAI(
            model="gemini-2.5-flash",
            temperature=0.0,
            project=project_id,
            location=location
        ).bind_tools([get_file_behavior])
        
        # Check subtasks for specific instructions
        context = ""
        for task in state.get("subtasks", []):
            if task.get("agent") == "malware_specialist":
                context += f"- Task: {task.get('task')}\n"
                context += f"- Context: {task.get('context')}\n"
        
        messages = [
            SystemMessage(content=MALWARE_ANALYSIS_PROMPT),
            HumanMessage(content=f"""
Please analyze these files:
{json.dumps(analysis_targets, indent=2)}

Triage Context:
{context}
            """)
        ]
        
        # Agent Loop (Simple 3-turn max)
        final_content = ""
        for turn in range(3):
            response = await llm.ainvoke(messages)
            messages.append(response)
            
            if response.tool_calls:
                for tc in response.tool_calls:
                    if tc["name"] == "get_file_behavior":
                        # Execute
                        res_txt = await get_file_behavior.ainvoke(tc["args"])
                        messages.append(ToolMessage(content=res_txt, tool_call_id=tc["id"]))
            else:
                final_content = response.content
                break
        
        # Parse Result
        try:
            # Clean markdown
            clean_content = str(final_content).replace("```json", "").replace("```", "").strip()
            result = json.loads(clean_content)
            
            # Store result
            if "specialist_results" not in state:
                state["specialist_results"] = {}
                
            state["specialist_results"]["malware"] = result
            
            # --- NEW Reporting Logic ---
            report_section = result.get("markdown_report", "")
            if report_section:
                current_report = state.get("final_report") or ""
                # Append if not already present (simple check)
                if "## Malware Specialist Analysis" not in current_report:
                    if current_report:
                        current_report += "\n\n"
                    current_report += report_section
                    state["final_report"] = current_report
            
            # Update Subtask Status
            new_subtasks = []
            for task in state.get("subtasks", []):
                if task.get("agent") == "malware_specialist":
                    task["status"] = "completed"
                    task["result_summary"] = result.get("summary")
                new_subtasks.append(task)
            state["subtasks"] = new_subtasks
            
            logger.info("malware_agent_success", verdict=result.get("verdict"))
            
        except Exception as e:
            logger.error("malware_parse_error", error=str(e))
            # Fallback
            state.setdefault("specialist_results", {})["malware"] = {
                "verdict": "Error",
                "summary": "Failed to parse analysis results."
            }
            
    return state
