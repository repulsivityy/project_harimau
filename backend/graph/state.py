from typing import TypedDict, Annotated, List, Dict, Any, Optional
from langchain_core.messages import BaseMessage
import operator

def merge_dicts(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    """Merges two dictionaries (shallow merge)."""
    return {**a, **b}

def last_value(a: Any, b: Any) -> Any:
    """Reducer that returns the last value (for scalar fields in parallel execution)."""
    return b if b is not None else a

def concat_reports(a: Optional[str], b: Optional[str]) -> Optional[str]:
    """Concatenate reports with separator (for parallel specialist reports)."""
    if not a: return b
    if not b: return a
    return f"{a}\n\n{b}"

def merge_graphs(a: Optional[Any], b: Optional[Any]) -> Optional[Any]:
    """
    Merge two NetworkX graphs (for parallel specialist execution).
    When specialists run in parallel, both expand the graph independently.
    This ensures both sets of updates are preserved.
    """
    if a is None: return b
    if b is None: return a
    
    # Import here to avoid circular deps
    import networkx as nx
    
    # Merge nodes (b's attributes win on conflicts)
    combined = a.copy()
    for node, data in b.nodes(data=True):
        if node in combined:
            # Node exists - merge attributes
            combined.nodes[node].update(data)
        else:
            # New node - add it
            combined.add_node(node, **data)
    
    # Merge edges
    for u, v, key, data in b.edges(keys=True, data=True):
        combined.add_edge(u, v, key=key, **data)
    
    return combined

class AgentState(TypedDict):
    """
    State schema for the Harimau Investigation Graph.
    Passed between all nodes in the workflow.
    """
    job_id: Annotated[str, last_value]
    ioc: Annotated[str, last_value]
    ioc_type: Annotated[Optional[str], last_value]
    
    # Chat History: Stores the chain of thought and tool outputs
    messages: Annotated[List[BaseMessage], operator.add]
    
    # Subtasks: Tasks generated by Triage for Specialists
    # Example: [{"agent": "malware", "task": "Analyze behavior of hash..."}]
    subtasks: Annotated[List[Dict[str, Any]], last_value]
    
    # Outputs: Final results from specialists
    # Example: {"malware": {"verdict": "malicious", "details": "..."}}
    specialist_results: Annotated[Dict[str, Any], merge_dicts]
    
    # Final Report: The generated markdown report
    # Reverting to last_value since Lead Hunter now assembles report manually
    final_report: Annotated[Optional[str], last_value]
    
    # Metadata: Timing, errors, etc.
    metadata: Annotated[Dict[str, Any], merge_dicts]
    
    # Investigation Graph: NetworkX cache for full entity storage
    # Stores complete GTI attributes for all entities and relationships
    # CRITICAL: Uses merge_graphs to preserve updates from parallel specialists
    investigation_graph: Annotated[Optional[Any], merge_graphs]  # nx.MultiDiGraph (using Any to avoid import)
    
    # Iteration Control
    loop_count: Annotated[int, operator.add]
    iteration: Annotated[int, last_value]  # Explicit iteration phase (0, 1, 2)
    
    # Lead Hunter's Strategic Plan (for transparency)
    lead_plan: Optional[str]
    lead_hunter_report: Annotated[Optional[str], last_value]  # Full synthesis report